/*
 * Cloud Functions
 * Since its founding in 1993, NVIDIA (NASDAQ: NVDA) has been a pioneer in accelerated computing. The company's invention of the GPU in 1999 sparked the growth of the PC gaming market, redefined computer graphics, ignited the era of modern AI and is fueling the creation of the metaverse. NVIDIA is now a full-stack computing company with data-center-scale offerings that are reshaping industry.
 *
 * The version of the OpenAPI document: 2.87.3
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.DeploymentResponse;
import com.konfigthis.client.model.FunctionDeploymentRequest;
import com.konfigthis.client.model.FunctionResponse;
import com.konfigthis.client.model.GpuSpecificationDto;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class FunctionDeploymentApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FunctionDeploymentApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public FunctionDeploymentApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call deleteByIdAndVersionCall(UUID functionId, UUID functionVersionId, Boolean graceful, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/nvcf/deployments/functions/{functionId}/versions/{functionVersionId}"
            .replace("{" + "functionId" + "}", localVarApiClient.escapeString(functionId.toString()))
            .replace("{" + "functionVersionId" + "}", localVarApiClient.escapeString(functionVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (graceful != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("graceful", graceful));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteByIdAndVersionValidateBeforeCall(UUID functionId, UUID functionVersionId, Boolean graceful, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'functionId' is set
        if (functionId == null) {
            throw new ApiException("Missing the required parameter 'functionId' when calling deleteByIdAndVersion(Async)");
        }

        // verify the required parameter 'functionVersionId' is set
        if (functionVersionId == null) {
            throw new ApiException("Missing the required parameter 'functionVersionId' when calling deleteByIdAndVersion(Async)");
        }

        return deleteByIdAndVersionCall(functionId, functionVersionId, graceful, _callback);

    }


    private ApiResponse<FunctionResponse> deleteByIdAndVersionWithHttpInfo(UUID functionId, UUID functionVersionId, Boolean graceful) throws ApiException {
        okhttp3.Call localVarCall = deleteByIdAndVersionValidateBeforeCall(functionId, functionVersionId, graceful, null);
        Type localVarReturnType = new TypeToken<FunctionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteByIdAndVersionAsync(UUID functionId, UUID functionVersionId, Boolean graceful, final ApiCallback<FunctionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteByIdAndVersionValidateBeforeCall(functionId, functionVersionId, graceful, _callback);
        Type localVarReturnType = new TypeToken<FunctionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteByIdAndVersionRequestBuilder {
        private final UUID functionId;
        private final UUID functionVersionId;
        private Boolean graceful;

        private DeleteByIdAndVersionRequestBuilder(UUID functionId, UUID functionVersionId) {
            this.functionId = functionId;
            this.functionVersionId = functionVersionId;
        }

        /**
         * Set graceful
         * @param graceful Query param to deactivate function for graceful shutdown (optional, default to false)
         * @return DeleteByIdAndVersionRequestBuilder
         */
        public DeleteByIdAndVersionRequestBuilder graceful(Boolean graceful) {
            this.graceful = graceful;
            return this;
        }
        
        /**
         * Build call for deleteByIdAndVersion
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteByIdAndVersionCall(functionId, functionVersionId, graceful, _callback);
        }


        /**
         * Execute deleteByIdAndVersion request
         * @return FunctionResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public FunctionResponse execute() throws ApiException {
            ApiResponse<FunctionResponse> localVarResp = deleteByIdAndVersionWithHttpInfo(functionId, functionVersionId, graceful);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteByIdAndVersion request with HTTP info returned
         * @return ApiResponse&lt;FunctionResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<FunctionResponse> executeWithHttpInfo() throws ApiException {
            return deleteByIdAndVersionWithHttpInfo(functionId, functionVersionId, graceful);
        }

        /**
         * Execute deleteByIdAndVersion request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<FunctionResponse> _callback) throws ApiException {
            return deleteByIdAndVersionAsync(functionId, functionVersionId, graceful, _callback);
        }
    }

    /**
     * Delete Function Deployment
     * Deletes the deployment associated with the specified function. Upon  deletion, any active instances will be terminated, and the function&#39;s status  will transition to &#39;INACTIVE&#39;. To undeploy a function version gracefully,  specify &#39;graceful&#x3D;true&#39; query parameter, allowing current tasks to complete  before terminating the instances. If the specified function version is public,  then Account Admin cannot perform this operation. Access to this endpoint mandates a bearer token with &#39;deploy_function&#39; scope in the  HTTP Authorization header. 
     * @param functionId Function id (required)
     * @param functionVersionId Function version id (required)
     * @return DeleteByIdAndVersionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public DeleteByIdAndVersionRequestBuilder deleteByIdAndVersion(UUID functionId, UUID functionVersionId) throws IllegalArgumentException {
        if (functionId == null) throw new IllegalArgumentException("\"functionId\" is required but got null");
            

        if (functionVersionId == null) throw new IllegalArgumentException("\"functionVersionId\" is required but got null");
            

        return new DeleteByIdAndVersionRequestBuilder(functionId, functionVersionId);
    }
    private okhttp3.Call detailsCall(UUID functionId, UUID functionVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/nvcf/deployments/functions/{functionId}/versions/{functionVersionId}"
            .replace("{" + "functionId" + "}", localVarApiClient.escapeString(functionId.toString()))
            .replace("{" + "functionVersionId" + "}", localVarApiClient.escapeString(functionVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call detailsValidateBeforeCall(UUID functionId, UUID functionVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'functionId' is set
        if (functionId == null) {
            throw new ApiException("Missing the required parameter 'functionId' when calling details(Async)");
        }

        // verify the required parameter 'functionVersionId' is set
        if (functionVersionId == null) {
            throw new ApiException("Missing the required parameter 'functionVersionId' when calling details(Async)");
        }

        return detailsCall(functionId, functionVersionId, _callback);

    }


    private ApiResponse<DeploymentResponse> detailsWithHttpInfo(UUID functionId, UUID functionVersionId) throws ApiException {
        okhttp3.Call localVarCall = detailsValidateBeforeCall(functionId, functionVersionId, null);
        Type localVarReturnType = new TypeToken<DeploymentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call detailsAsync(UUID functionId, UUID functionVersionId, final ApiCallback<DeploymentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = detailsValidateBeforeCall(functionId, functionVersionId, _callback);
        Type localVarReturnType = new TypeToken<DeploymentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DetailsRequestBuilder {
        private final UUID functionId;
        private final UUID functionVersionId;

        private DetailsRequestBuilder(UUID functionId, UUID functionVersionId) {
            this.functionId = functionId;
            this.functionVersionId = functionVersionId;
        }

        /**
         * Build call for details
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return detailsCall(functionId, functionVersionId, _callback);
        }


        /**
         * Execute details request
         * @return DeploymentResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public DeploymentResponse execute() throws ApiException {
            ApiResponse<DeploymentResponse> localVarResp = detailsWithHttpInfo(functionId, functionVersionId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute details request with HTTP info returned
         * @return ApiResponse&lt;DeploymentResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DeploymentResponse> executeWithHttpInfo() throws ApiException {
            return detailsWithHttpInfo(functionId, functionVersionId);
        }

        /**
         * Execute details request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DeploymentResponse> _callback) throws ApiException {
            return detailsAsync(functionId, functionVersionId, _callback);
        }
    }

    /**
     * Get Function Deployment Details
     * Allows Account Admins to retrieve the deployment details of the specified  function version. Access to this endpoint mandates a bearer token with &#39;deploy_function&#39; scope in the  HTTP Authorization header. 
     * @param functionId Function id (required)
     * @param functionVersionId Function version id (required)
     * @return DetailsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public DetailsRequestBuilder details(UUID functionId, UUID functionVersionId) throws IllegalArgumentException {
        if (functionId == null) throw new IllegalArgumentException("\"functionId\" is required but got null");
            

        if (functionVersionId == null) throw new IllegalArgumentException("\"functionVersionId\" is required but got null");
            

        return new DetailsRequestBuilder(functionId, functionVersionId);
    }
    private okhttp3.Call initiateDeploymentForVersionCall(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = functionDeploymentRequest;

        // create path and map variables
        String localVarPath = "/v2/nvcf/deployments/functions/{functionId}/versions/{functionVersionId}"
            .replace("{" + "functionId" + "}", localVarApiClient.escapeString(functionId.toString()))
            .replace("{" + "functionVersionId" + "}", localVarApiClient.escapeString(functionVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call initiateDeploymentForVersionValidateBeforeCall(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'functionId' is set
        if (functionId == null) {
            throw new ApiException("Missing the required parameter 'functionId' when calling initiateDeploymentForVersion(Async)");
        }

        // verify the required parameter 'functionVersionId' is set
        if (functionVersionId == null) {
            throw new ApiException("Missing the required parameter 'functionVersionId' when calling initiateDeploymentForVersion(Async)");
        }

        // verify the required parameter 'functionDeploymentRequest' is set
        if (functionDeploymentRequest == null) {
            throw new ApiException("Missing the required parameter 'functionDeploymentRequest' when calling initiateDeploymentForVersion(Async)");
        }

        return initiateDeploymentForVersionCall(functionId, functionVersionId, functionDeploymentRequest, _callback);

    }


    private ApiResponse<DeploymentResponse> initiateDeploymentForVersionWithHttpInfo(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest) throws ApiException {
        okhttp3.Call localVarCall = initiateDeploymentForVersionValidateBeforeCall(functionId, functionVersionId, functionDeploymentRequest, null);
        Type localVarReturnType = new TypeToken<DeploymentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call initiateDeploymentForVersionAsync(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest, final ApiCallback<DeploymentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = initiateDeploymentForVersionValidateBeforeCall(functionId, functionVersionId, functionDeploymentRequest, _callback);
        Type localVarReturnType = new TypeToken<DeploymentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class InitiateDeploymentForVersionRequestBuilder {
        private final List<GpuSpecificationDto> deploymentSpecifications;
        private final UUID functionId;
        private final UUID functionVersionId;

        private InitiateDeploymentForVersionRequestBuilder(List<GpuSpecificationDto> deploymentSpecifications, UUID functionId, UUID functionVersionId) {
            this.deploymentSpecifications = deploymentSpecifications;
            this.functionId = functionId;
            this.functionVersionId = functionVersionId;
        }

        /**
         * Build call for initiateDeploymentForVersion
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            return initiateDeploymentForVersionCall(functionId, functionVersionId, functionDeploymentRequest, _callback);
        }

        private FunctionDeploymentRequest buildBodyParams() {
            FunctionDeploymentRequest functionDeploymentRequest = new FunctionDeploymentRequest();
            functionDeploymentRequest.deploymentSpecifications(this.deploymentSpecifications);
            return functionDeploymentRequest;
        }

        /**
         * Execute initiateDeploymentForVersion request
         * @return DeploymentResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public DeploymentResponse execute() throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            ApiResponse<DeploymentResponse> localVarResp = initiateDeploymentForVersionWithHttpInfo(functionId, functionVersionId, functionDeploymentRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute initiateDeploymentForVersion request with HTTP info returned
         * @return ApiResponse&lt;DeploymentResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DeploymentResponse> executeWithHttpInfo() throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            return initiateDeploymentForVersionWithHttpInfo(functionId, functionVersionId, functionDeploymentRequest);
        }

        /**
         * Execute initiateDeploymentForVersion request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DeploymentResponse> _callback) throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            return initiateDeploymentForVersionAsync(functionId, functionVersionId, functionDeploymentRequest, _callback);
        }
    }

    /**
     * Deploy Function
     * Initiates deployment for the specified function version. Upon invocation of  this endpoint, the function&#39;s status transitions to &#39;DEPLOYING&#39;. If the  specified function version is public, then Account Admin cannot perform this  operation. Access to this endpoint mandates a bearer token with &#39;deploy_function&#39; scope in the  HTTP Authorization header. 
     * @param functionId Function id (required)
     * @param functionVersionId Function version id (required)
     * @param functionDeploymentRequest  (required)
     * @return InitiateDeploymentForVersionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public InitiateDeploymentForVersionRequestBuilder initiateDeploymentForVersion(List<GpuSpecificationDto> deploymentSpecifications, UUID functionId, UUID functionVersionId) throws IllegalArgumentException {
        if (deploymentSpecifications == null) throw new IllegalArgumentException("\"deploymentSpecifications\" is required but got null");
        if (functionId == null) throw new IllegalArgumentException("\"functionId\" is required but got null");
            

        if (functionVersionId == null) throw new IllegalArgumentException("\"functionVersionId\" is required but got null");
            

        return new InitiateDeploymentForVersionRequestBuilder(deploymentSpecifications, functionId, functionVersionId);
    }
    private okhttp3.Call updateSpecsCall(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = functionDeploymentRequest;

        // create path and map variables
        String localVarPath = "/v2/nvcf/deployments/functions/{functionId}/versions/{functionVersionId}"
            .replace("{" + "functionId" + "}", localVarApiClient.escapeString(functionId.toString()))
            .replace("{" + "functionVersionId" + "}", localVarApiClient.escapeString(functionVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSpecsValidateBeforeCall(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'functionId' is set
        if (functionId == null) {
            throw new ApiException("Missing the required parameter 'functionId' when calling updateSpecs(Async)");
        }

        // verify the required parameter 'functionVersionId' is set
        if (functionVersionId == null) {
            throw new ApiException("Missing the required parameter 'functionVersionId' when calling updateSpecs(Async)");
        }

        // verify the required parameter 'functionDeploymentRequest' is set
        if (functionDeploymentRequest == null) {
            throw new ApiException("Missing the required parameter 'functionDeploymentRequest' when calling updateSpecs(Async)");
        }

        return updateSpecsCall(functionId, functionVersionId, functionDeploymentRequest, _callback);

    }


    private ApiResponse<DeploymentResponse> updateSpecsWithHttpInfo(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest) throws ApiException {
        okhttp3.Call localVarCall = updateSpecsValidateBeforeCall(functionId, functionVersionId, functionDeploymentRequest, null);
        Type localVarReturnType = new TypeToken<DeploymentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateSpecsAsync(UUID functionId, UUID functionVersionId, FunctionDeploymentRequest functionDeploymentRequest, final ApiCallback<DeploymentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSpecsValidateBeforeCall(functionId, functionVersionId, functionDeploymentRequest, _callback);
        Type localVarReturnType = new TypeToken<DeploymentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateSpecsRequestBuilder {
        private final List<GpuSpecificationDto> deploymentSpecifications;
        private final UUID functionId;
        private final UUID functionVersionId;

        private UpdateSpecsRequestBuilder(List<GpuSpecificationDto> deploymentSpecifications, UUID functionId, UUID functionVersionId) {
            this.deploymentSpecifications = deploymentSpecifications;
            this.functionId = functionId;
            this.functionVersionId = functionVersionId;
        }

        /**
         * Build call for updateSpecs
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            return updateSpecsCall(functionId, functionVersionId, functionDeploymentRequest, _callback);
        }

        private FunctionDeploymentRequest buildBodyParams() {
            FunctionDeploymentRequest functionDeploymentRequest = new FunctionDeploymentRequest();
            functionDeploymentRequest.deploymentSpecifications(this.deploymentSpecifications);
            return functionDeploymentRequest;
        }

        /**
         * Execute updateSpecs request
         * @return DeploymentResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public DeploymentResponse execute() throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            ApiResponse<DeploymentResponse> localVarResp = updateSpecsWithHttpInfo(functionId, functionVersionId, functionDeploymentRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateSpecs request with HTTP info returned
         * @return ApiResponse&lt;DeploymentResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DeploymentResponse> executeWithHttpInfo() throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            return updateSpecsWithHttpInfo(functionId, functionVersionId, functionDeploymentRequest);
        }

        /**
         * Execute updateSpecs request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DeploymentResponse> _callback) throws ApiException {
            FunctionDeploymentRequest functionDeploymentRequest = buildBodyParams();
            return updateSpecsAsync(functionId, functionVersionId, functionDeploymentRequest, _callback);
        }
    }

    /**
     * Update Function Deployment
     * Updates the deployment specs of the specified function version. It&#39;s important  to note that GPU type and backend configurations cannot be modified through  this endpoint. If the specified function is public, then Account Admin cannot  perform this operation. Access to this endpoint mandates a bearer token with &#39;deploy_function&#39; scope in the  HTTP Authorization header. 
     * @param functionId Function id (required)
     * @param functionVersionId Function version id (required)
     * @param functionDeploymentRequest  (required)
     * @return UpdateSpecsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public UpdateSpecsRequestBuilder updateSpecs(List<GpuSpecificationDto> deploymentSpecifications, UUID functionId, UUID functionVersionId) throws IllegalArgumentException {
        if (deploymentSpecifications == null) throw new IllegalArgumentException("\"deploymentSpecifications\" is required but got null");
        if (functionId == null) throw new IllegalArgumentException("\"functionId\" is required but got null");
            

        if (functionVersionId == null) throw new IllegalArgumentException("\"functionVersionId\" is required but got null");
            

        return new UpdateSpecsRequestBuilder(deploymentSpecifications, functionId, functionVersionId);
    }
}
